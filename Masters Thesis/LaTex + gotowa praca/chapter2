\chapter{Quantum circuits}
\thispagestyle{chapterBeginStyle}
\label{chapter2}

In the previous chapter we introduced a new concept called \textbf{quantum circuit}. In this chapter, we will describe it in detail, which will enable us to create algorithms, which will be presented in the next chapter.

\section{Qubits}

In classical computers information is stored using \textbf{bits}. These entities can be in two states - 0 or 1. Thanks to this, we can encode any information as a string of bits in appropriate states.

In the example \ref{example_0_1_states} from the previous chapter we introduced two vectors (states) - $|0\rangle = \begin{pmatrix} 1 \\ 0 \end{pmatrix}$ and $|1\rangle = \begin{pmatrix} 0 \\ 1 \end{pmatrix}$. These two states can be quantum equivalents of classical states 0 and 1. They are orthonormal
\[ \langle 0 | 1 \rangle = \begin{pmatrix} 1 & 0\end{pmatrix} \begin{pmatrix} 0 \\ 1 \end{pmatrix} = 1 \cdot 0 + 0 \cdot 1 = 0,\]
so they can create a basis for a vector in Hilbert space. Hence, such a vector can be represented as a combination of these two states
\[ |\psi \rangle = \alpha |0\rangle + \beta |1\rangle. \]

The above vector is the basic information unit in quantum computer science - \textbf{qubit}. Comparing to classical bit, which can be only in 2 states, qubit can be in an infinite amount of states (because it can be in any combination of states $|0\rangle$ and $|1\rangle$). Such a vector can be represented on the \textbf{Bloch sphere} (given below).

\begin{figure}[ht]
\centering
\includegraphics[scale=0.1]{bloch_sphere}
\caption{Representation of a qubit on the Bloch sphere.}
\end{figure}

\begin{remark}
(?) Nie wiem czemu można przedstawić stany $|0\rangle$ i $|1\rangle$ na jednej osi, a nie jako prostopadłe (?)
\end{remark}


\section{Reversible circuits}

A classical circuit can be considered as a \textbf{reversible} taking into account two criteria - \textit{physical} and \textit{logical} reversibility. In this work we will discuss only the second one.

A \textit{logically reversible circuit} is a circuit, in which action of each logical gate can be undone. In other words, we can restore the state of each bit, before the gate was applied.

A simple, classical, one bit logic gate - \textbf{NOT} gate is fully reversible. Let's say, we have a bit in the state 0 and apply the NOT gate to it. We receive a bit in the state 1. But during the whole procedure we didn't lose any information about the previous state of the considered bit. We can reverse this operation by applying another NOT gate and change bit's state from 1 to 0 (a NOT gate is it's own inverse gate).

Now, let's consider a two bit \textbf{OR} gate. It implements a simple logical operation

\begin{table}[ht]
    \centering
    \begin{tabular}{c|c|c}
         A & B & $A \vee B$ \\
         0 & 0 & 0 \\
         0 & 1 & 1 \\
         1 & 0 & 1 \\
         1 & 1 & 1
    \end{tabular}
    \caption{The action of the OR gate.}
    \label{tab:or_gate_action}
\end{table}

We can see, that if we apply this gate to two bits and receive 0, it is obvious, that these bits were in state 0. But if we receive 1 as an output it is impossible to determine, which one of them was in the state 1 (both of them could also be in this state). In the computing process we lost some information about the initial state of our two bits.

Quantum circuit is a version of a reversible circuit. In fact, each logic gate used in a quantum circuit can be considered as an unitary operator (or an unitary matrix). Thanks to this, an action of each quantum gate can be undone by applying the inverse gate.

\begin{remark}
A quantum gate can be its own inverse gate. As we stated in the first chapter, a matrix which is its own inverse is called \textit{Hermitian}.
\end{remark}

\section{Representation of a quantum circuit}

Quantum circuits will be presented in the further part of this work in the following way:

\begin{itemize}
    \item The time evolution of a circuit will be associated with the horizontal axis. Because of this, left side of each schema of a circuit will be the beginning of the computation,
    \item Each qubit will have assigned a horizontal line. It will demonstrate the time evolution of the qubits state,
    \item Quantum gates will be presented in the form of boxes.
\end{itemize}

An example quantum circuit is presented below:

\[  \scalebox{2.0}{\Qcircuit @C=1em @R=1em {
\lstick{|\psi\rangle} & \gate{H} & \targ & \meter  \\
\lstick{|\phi\rangle} & \qw & \ctrl{-1} & \meter \\
\lstick{|\theta\rangle} & {/^{n}} \qw & \gate{X} & \meter
}} \]

We will now discuss only two of the occurring in the above circuit symbols (rest of them will be explained in detail in next sections).

The symbol given below symbolizes a measurement of a qubit

\[ \scalebox{2.5}{\Qcircuit @C=1em @R=1em {
& \meter & \rstick{} \cw
}} \]

Sometimes we will replace many lines representing time evolution of many qubits' states using the following notation


\[ \scalebox{2.5}{\Qcircuit @C=1em @R=1em {
& {/^{n}} \qw & \qw
}} \]


\section{Single qubit quantum gates}

In contrast to the classical model of computation, we can create infinitely many single qubit quantum gates (in classic case we could only use the \textit{NOT} gate on one bit). It is possible, because we can associate each quantum gate with a rotation of the quantum state on the Bloch sphere. It is obvious, that we can make infinitely many different rotations, which proves our statement.

Below is given notation for chosen single qubit quantum gates, which will be used in this work.

\paragraph{Identity gate}

\[ I = \begin{pmatrix} 1 & 0 \\ 0 & 1 \end{pmatrix} \]

\paragraph{Pauli X gate (NOT gate)}

\[ X = \begin{pmatrix} 0 & 1 \\ 1 & 0 \end{pmatrix} \]

\paragraph{Pauli Z gate}

\[ Z = \begin{pmatrix} 1 & 0 \\ 0 & -1 \end{pmatrix} \]

\paragraph{Hadamard gate}

\[ H =  \frac{1}{\sqrt{2}} \begin{pmatrix} 1 & 1 \\ 1 & -1 \end{pmatrix} \]

\paragraph{Phase shift ($R_k$ gate)}

\[ R_k = \begin{pmatrix} 1 & 0 \\ 0 & e^{\frac{2 \pi i}{2^k}} \end{pmatrix} \]

\begin{remark}
In literature the gate $R_k$ is often replaced with the $R_\phi$ gate, which is equivalent to

\[ R_\phi = \begin{pmatrix} 1 & 0 \\ 0 & e^{i \phi} \end{pmatrix}. \]

Despite this fact, we will use only the $R_k$ gate.
\end{remark}

\begin{remark}
As stated in the first chapter, when we are considering a complex physical system (made for example from two qubits) we are using the tensor product of the two component subsystems. Let's see at the quantum circuit given below.

\[  \scalebox{2.0}{\Qcircuit @C=1em @R=1em {
\lstick{|\psi\rangle} & \gate{H} & \rstick{|\psi'\rangle} \qw \\
\lstick{|\phi\rangle} & \gate{I} & \rstick{|\phi'\rangle} \qw \\
}} \]

If we would like to replace the gates \textit{H} and \textit{I} with just one gate (let's call it \textit{C}) we would have to conduct the following procedure

\[ C = H \otimes I = \frac{1}{\sqrt{2}} \begin{pmatrix} 1 & 1 \\ 1 & -1 \end{pmatrix} \otimes \begin{pmatrix} 1 & 0 \\ 0 & 1\end{pmatrix} = \frac{1}{\sqrt{2}} \begin{pmatrix} 1 & 0 & 1 & 0 \\ 0 & 1 & 0 & 1 \\ 1 & 0 & -1 & 0 \\ 0 & 1 & 0 & -1 \end{pmatrix}.\]

We can see, that we can replace the \textit{C} gate with just \textbf{one layer} of smaller quantum gates. But it is not always possible. We will give an example of such a case in the next section.
\end{remark}

\section{Multiple qubit quantum gates}

In the first chapter we stated, that not all compound systems can be expressed in the form of tensor product of its subsystems. We called this phenomenon \textit{entanglement}. This property of quantum entities is often used in quantum computing. Using entanglement we can create \textbf{controlled gates}. A simple example of a controlled gate is the \textbf{controlled-NOT} gate (sometimes denoted as \textbf{CNOT}). In the matrix form it is written as

\[ CNOT = \begin{pmatrix} 1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 0 & 1 \\ 0 & 0 & 1 & 0 \end{pmatrix} \]

We can see, that we cannot receive such a matrix as a result of tensor product of smaller matrices.

The \textit{CNOT} gate is represented in quantum circuits by the symbol

\[  \scalebox{2.0}{\Qcircuit @C=1em @R=1em {
 & \ctrl{1} & \qw \\
 & \targ & \qw \\
}} \]

The upper qubit is called a \textbf{control} qubit, and the bottom qubit is referred as to \textbf{target} qubit. To better understand what this quantum gate does, let's consider the following circuit

\[  \scalebox{2.0}{\Qcircuit @C=1em @R=1em {
\lstick{|\psi\rangle} & \ctrl{1} & \rstick{|\psi\rangle} \qw \\
\lstick{|\phi\rangle} & \targ & \rstick{|\phi \oplus \psi \rangle} \qw \\
}} \]

The \textit{CNOT} gate performs some operation (we will describe this operation in a moment), when the control qubit is in state $|1\rangle$. Otherwise, the whole system is leaved without any change.

In fact, the \textit{CNOT} gate can be understood as follows - it leaves the control qubit in the same state, and the bottom qubit becomes the result of \textit{addition modulo two} of the two qubits' states. Let's say, we have qubits in states $|0\rangle$ and $|1\rangle$ (accordingly control and target qubits). The usage of \textit{CNOT} gate can be written as

\[ CNOT |0\rangle \otimes |1\rangle = CNOT \begin{pmatrix} 1 \\ 0 \end{pmatrix} \otimes \begin{pmatrix} 0 \\ 1 \end{pmatrix} = \begin{pmatrix} 1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 0 & 1 \\ 0 & 0 & 1 & 0 \end{pmatrix} \begin{pmatrix} 0 \\ 1 \\ 0 \\ 0 \end{pmatrix} = \begin{pmatrix} 0 \\ 1 \\ 0 \\ 0\end{pmatrix} = |0\rangle \otimes |1\rangle.\]

Now, let's consider qubits in states $|1\rangle$ and $|1\rangle$. The result of the above circuit for qubits in such states is equal to

\[ CNOT |1\rangle \otimes |1\rangle = CNOT \begin{pmatrix} 0 \\ 1 \end{pmatrix} \otimes \begin{pmatrix} 0 \\ 1 \end{pmatrix} = \begin{pmatrix} 1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 0 & 1 \\ 0 & 0 & 1 & 0 \end{pmatrix} \begin{pmatrix} 0 \\ 0 \\ 0 \\ 1 \end{pmatrix} = \begin{pmatrix} 0 \\ 0 \\ 1 \\ 0 \end{pmatrix} = |1\rangle \otimes |0\rangle.\]

It is obvious, that $0 + 1 \ (mod \ 2) \equiv 1$ and $1 + 1 \ (mod \ 2) \equiv 0$, so we have shown, that understanding of the \textit{CNOT} gate in terms of the modular addition is correct. All possible results of the \textit{CNOT} gate are given in the table below.

\begin{table}[ht]
    \centering
    \begin{tabular}{c|c|c}
         $|\psi\rangle$ & $|\phi\rangle$ & $CNOT \  |\psi \phi \rangle$ \\ \hline
         $|0\rangle$ & $|0\rangle$ & $|00\rangle$ \\
         $|0\rangle$ & $|1\rangle$ & $|01\rangle$ \\
         $|1\rangle$ & $|0\rangle$ & $|11\rangle$ \\
         $|1\rangle$ & $|1\rangle$ & $|10\rangle$ \\
    \end{tabular}
    \caption{Actions of the \textit{CNOT} gate.}
    \label{tab:my_label}
\end{table}

The \textit{CNOT} gate is a simple extension of the \textit{NOT} gate. We can see, that the bottom right block of the \textit{CNOT} matrix is just the \textit{X} matrix. We can extend this reasoning, to create a whole class of controlled gates. Let's say, we have some quantum gate \textit{M} in the form

\[ M = \begin{pmatrix} m_{11} & m_{12} \\ m_{21} & m_{22}\end{pmatrix}. \]

The controlled version of this gate would have a form

\[ cM = \begin{pmatrix} 1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & m_{11} & m_{12} \\ 0 & 0 & m_{21} & m_{22} \end{pmatrix}. \]

Of course we can extend the simple case with a $2 \times 2$ matrix to a matrix with many inputs (acting on many qubits). Such a case will be represented by symbol

\[  \scalebox{1.5}{\Qcircuit @C=1em @R=.5em {
& \ctrl{1} & \qw \\
& \multigate{3}{M} & \qw \\
& \ghost{M} & \qw \\
& \ghost{M} & \qw \\
& \ghost{M} & \qw
}} \]

or 

\[  \scalebox{2.5}{\Qcircuit @C=1em @R=.5em {
& \qw & \ctrl{1} & \qw \\
& {/^{n}} \qw & \gate{M} & \qw 
}} \]

\begin{remark}
As we can see from the below calculations

\[ \begin{pmatrix} 1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 0 & 1 \\ 0 & 0 & 1 & 0 \end{pmatrix} \begin{pmatrix} 1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 0 & 1 \\ 0 & 0 & 1 & 0 \end{pmatrix} = \begin{pmatrix} 1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 1 \end{pmatrix} \]

the \textit{CNOT} gate is its own inverse gate.
\end{remark}

\section{Many-controlled quantum gates and ancilla qubits}

We can also extend the controlled gate model by adding more control qubits. The simplest example of quantum gate with many control qubits is the \textbf{Toffoli} gate. It will be denoted as

\[  \scalebox{2.5}{\Qcircuit @C=1em @R=1em {
& \lstick{|\psi\rangle} & \ctrl{2} & \qw & \rstick{|\psi\rangle}  \\
& \lstick{|\phi\rangle} & \ctrl{1} & \qw & \rstick{|\phi\rangle}  \\
& \lstick{|\theta\rangle} & \targ & \qw & \rstick{|\theta \oplus \psi\phi\rangle} 
}} \]
\[\]
It's action is similar to the one of the \textit{CNOT} gate. It applies addition modulo two on the target qubit, if two control qubits are in the state $|1\rangle$. It's effect is presented in the table below.

\begin{table}[ht]
    \centering
    \begin{tabular}{c|c}
         Input & Output \\ \hline
         $|000\rangle$ & $|000\rangle$ \\
         $|001\rangle$ & $|001\rangle$ \\
         $|010\rangle$ & $|010\rangle$ \\
         $|011\rangle$ & $|011\rangle$ \\
         $|100\rangle$ & $|100\rangle$ \\
         $|101\rangle$ & $|101\rangle$ \\
         $|110\rangle$ & $|111\rangle$ \\
         $|111\rangle$ & $|110\rangle$ \\
    \end{tabular}
    \caption{Actions of the \textit{Toffoli} gate.}
    \label{tab:my_label}
\end{table}

It can be written in the matrix form as

\[ \begin{pmatrix} 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 \\ 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 \\ 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 \\ 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 \end{pmatrix}. \]


\begin{remark}
At this point we will assume, that it is physically possible to implement \textit{CNOT} and \textit{Toffoli} gates. Because of this assumption, we can try to break down more complicated gates into \textit{CNOT} and \textit{Toffoli} gates. This topic will be expanded in the next section.
\end{remark}

Of course we can add next control qubits and receive for example such gate:

\[  \scalebox{2.0}{\Qcircuit @C=1em @R=1em {
 & \ctrl{4} & \qw \\
 & \ctrl{3} & \qw \\
 & \ctrl{2} & \qw \\
 & \ctrl{1} & \qw \\
 & \gate{M} & \qw \\
}} \]

\begin{remark}
\textit{NOT} gates with more than two control qubits will be denoted as $C^n NOT$ gates (where \textit{n} is the number of control qubits).
\end{remark}

Unfortunately, it might be physically impossible to construct such a gate. But, as we mentioned in the above remark, we can break it down into \textit{CNOT} and \textit{Toffoli} gates. To achieve this goal we will have to use \textbf{ancilla qubits}.

\subsection{Ancilla qubits}

\textit{Ancilla} qubits are additional qubits, which expand our work space. They can be, for example, taken from some other part of a quantum circuit, where they are currently not used. Because of this, it is sometimes necessary to return them in unchanged state to the original location in the circuit.

We will now introduce four types of \textit{ancilla} qubits. Although this notation is not officially used (it was taken from \ref{craig_gidney}), we will use it, because it perfectly captures the nature of each \textit{ancilla} qubit type.

\begin{itemize}
    \item \textbf{Burnable qubits} - initially, those qubits are in state $|0\rangle$ and there are no requirements about the state, in which it is to be found at the end of the computation.
    \item \textbf{Zeroed qubits} - initially they are in state $|0\rangle$ and have to be in this state, when we are not going to use them any more.
    \item \textbf{Garbage qubits} - the initial state of these qubits is unknown and there are no restrictions concerning the final state.
    \item \textbf{Borrowed qubits} - at the beginning of the computation they can be in any state and have to be returned in the same state.
\end{itemize}

\subsection{Construction of $C^n NOT$ gate}

Our first goal is to break down the below gate into more gates with fewer control qubits.

\[  \scalebox{2.0}{\Qcircuit @C=1em @R=1em {
& \lstick{|a\rangle} & \ctrl{4} & \qw & \rstick{|a\rangle}  \\
& \lstick{|b\rangle} & \ctrl{3} & \qw & \rstick{|b\rangle}  \\
& \lstick{|c\rangle} & \ctrl{2} & \qw & \rstick{|c\rangle}  \\
& \lstick{|d\rangle} & \ctrl{1} & \qw & \rstick{|d\rangle}  \\
& \lstick{|T\rangle} & \targ & \qw & \rstick{|T \oplus abcd\rangle} 
}} \]

\begin{remark}
We will use the following notation to denote different types of \textit{ancilla} qubits:
\begin{itemize}
    \item $|BU_i\rangle$ for burnable qubits,
    \item $|Z_i\rangle$ for zeroed qubits,
    \item $|G_i\rangle$ for garbage qubits,
    \item $|BO_i\rangle$ for borrowed qubits,
\end{itemize}
where \textit{i} will be the index for the following \textit{ancilla} qubits.
\end{remark}

\paragraph{Simple decomposition of the $C^n NOT$ gate with one burnable qubit}

If we have one additional burnable qubit to use, we can toggle it, if half of the control qubits are in state $|1\rangle$. As a result we obtain the following circuit:

\[  \scalebox{2.0}{\Qcircuit @C=1em @R=1em {
& \lstick{|a\rangle} & \ctrl{4} & \qw & \qw & \rstick{|a\rangle}  \\
& \lstick{|b\rangle} & \ctrl{3} & \qw & \qw & \rstick{|b\rangle}  \\
& \lstick{|c\rangle} & \qw & \ctrl{3} & \qw & \rstick{|c\rangle}  \\
& \lstick{|d\rangle} & \qw & \ctrl{2} & \qw & \rstick{|d\rangle}  \\
& \lstick{|BU_1\rangle} & \targ & \ctrl{1} & \qw & \rstick{|0 \oplus ab\rangle = |ab\rangle}  \\
& \lstick{|T\rangle} & \qw & \targ & \qw & \rstick{|T \oplus abcd\rangle} 
}} \]

\paragraph{Simple decomposition of the $C^n NOT$ gate with one zeroed qubit}

At the end of the previous section we have shown, that the \textit{CNOT} gate is its won inverse gate. In fact, any $C^nNOT$ gate is its own inverse gate. We will use this property, while using the \textit{zeroed} qubit. If we apply the $C^nNOT$ gate to this \textit{ancilla} qubit for the first time, its state might change. But we can cancel the action of the first gate by using the $C^nNOT$ gate second time. This reasoning gives us the following quantum circuit:

\[  \scalebox{2.0}{\Qcircuit @C=1em @R=1em {
& \lstick{|a\rangle} & \ctrl{4} & \qw & \ctrl{4} & \qw & \rstick{|a\rangle}  \\
& \lstick{|b\rangle} & \ctrl{3} & \qw & \ctrl{3} & \qw & \rstick{|b\rangle}  \\
& \lstick{|c\rangle} & \qw & \ctrl{3} & \qw & \qw & \rstick{|c\rangle}  \\
& \lstick{|d\rangle} & \qw & \ctrl{2} & \qw & \qw & \rstick{|d\rangle}  \\
& \lstick{|Z_1\rangle} & \targ & \ctrl{1} &\targ & \qw & \rstick{|Z_1\rangle = |0\rangle}  \\
& \lstick{|T\rangle} & \qw & \targ & \qw & \qw & \rstick{|T \oplus abcd\rangle} 
}} \]

\paragraph{Simple decomposition of the $C^n NOT$ gate with one garbage qubit}

\paragraph{Simple decomposition of the $C^n NOT$ gate with one borrowed qubit}





\section{Elementary quantum gates} \label{elementary_quantum_gates}

