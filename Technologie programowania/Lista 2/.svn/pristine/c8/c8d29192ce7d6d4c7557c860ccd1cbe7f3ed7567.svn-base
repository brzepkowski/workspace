import java.io.*;

import java.net.*;
import java.util.ArrayList;

import javax.swing.text.html.HTMLDocument.Iterator;
import java.util.*; /* import bibliotek narzedziowych */
import java.net.*; /*import bibliotek odpowiedzialnych za komunikacje sieciowa */


public class SocketServer extends Thread{
	
  // ServerSocket for accepting new connections (may be important to add private)
  ServerSocket server = null;
  
  //ArrayList of all connected Clients - enables to send messages to all of them
  public Hashtable allStreams = new Hashtable(); //<==== Can be changed to HashMap
  
  int numberOfPlayers = 0;
  
  private static int limitOfPlayers = 2;
  public static int tokens = 0;
  public static int smallBlindBet;
  public static int bigBlindBet;
  
  public Table table;


  
  // Constructor of SocketServer creates port on which it will be listening
  //to new Clients
  SocketServer(int port, int limitOfPlayers) {   
    
	  listenSocket(port, limitOfPlayers);
  }
  
  
  // Method listen() enables to listen forever for new clients
  public void listenSocket(int port, int limitOfPlayers) {
	  
	  try {
		server = new ServerSocket(port);
	
	  
	  System.out.println("Uruchomiono serwer na porcie: " + port);
	  
	  while(numberOfPlayers < limitOfPlayers) {
		  
			  Socket client = server.accept();
			  
			  numberOfPlayers++;
      
			  System.out.println("Nawiazano polaczenie z:" + client);
      
      		  PrintWriter out = new PrintWriter(client.getOutputStream(), true);
      
      		  allStreams.put(numberOfPlayers, out);
      		 
      		  // Creates a Thread to deal with new connection
      		  //(A thread is generally defined as separate line of control within one  process)
      		  //(Many task done at the same time (multitasking).
      		  new ServerThread (this, client);
      		  
      		  out.println(numberOfPlayers);
      		  
      } 
	  //Creation of Object table
	  if (numberOfPlayers == limitOfPlayers) {
		  table = new Table(this);
		  broadcast("LimitOfPlayers-" + limitOfPlayers + "-0-0-0-0");
		  broadcast("Tokens-" + tokens + "-0-0-0-0"); // Additional zeros not to make error with sending
	  }
	  }
	  catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
  } 
  
  
 	// Gets register/specification of all connected Clients
  	Enumeration getAllStreams() {
  
	  	return allStreams.elements();
  	}

  	public void broadcast(String message) {
  		
  		//We have to synchronize, because Clients may disconnect
  		synchronized (allStreams) {
  			
  			for (Enumeration enumeration = getAllStreams(); enumeration.hasMoreElements(); ) {
  				
  				PrintWriter out = (PrintWriter)enumeration.nextElement();
  				
  				out.println(message);
  				
  			}
  			
  		}
  	}
  	
  	
  	// <=== It is important to write method which will remove clients from server

  public static void main(String[] args) {
	 
	  int port = 0;
	 
	  try {
		  // args[0] - number of port || args[1] - limitOfPlayers || args[2] - tokens for all players 
		  // args[3] - Bet of Small Blind || args[4] - Bet of Big Blind
		  port = Integer.parseInt(args[0]);
		  setLimitOfPlayers(Integer.parseInt(args[1]));
		  tokens = Integer.parseInt(args[2]);
		  smallBlindBet = Integer.parseInt(args[3]);
		  bigBlindBet = Integer.parseInt(args[4]);
	  }
	  catch (NumberFormatException ex) {
		  System.out.println("Nieprawidlowa dana");
	  }
	 
	  new SocketServer(port, getLimitOfPlayers());
  }


public static int getLimitOfPlayers() {
	return limitOfPlayers;
}


public static void setLimitOfPlayers(int limitOfPlayers) {
	SocketServer.limitOfPlayers = limitOfPlayers;
}
}